<!doctype html>
<html lang="en">
<head>
    <!--
       This Amos Professional Manual is written by asymetrix for the Amiga community and should stay completely FREE FOREVER.
       Created 2008. :)

       It was created from the original AMOS Professional Manual by Europress Software Ltd.

       It has been updated by Fredrik Rambris.
   -->
    <title>String Functions - AMOS Professional Manual</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="keywords" content="Amos Professional, Amiga, Programming, Basic, Francois Lionet, Europress Software Ltd, Amos, computing, code, AmigaDOS">
    <meta name="author" content="asymetrix,Fredrik Rambris">
    <link rel="GitHub" href="https://github.com/fredrik-rambris/amospromanual">
    <meta property="og:site_name" content="AMOS Professional Manual">
    <meta property="og:image" content="https://amospromanual.dev/images/cover.jpg">
    <link rel="stylesheet" type="text/css" href="styles.css">
    <link rel="canonical" href="https://amospromanual.dev/05-02-string-functions.html">
</head>
<body>


<section>
    <h1>String Functions</h1>

    <P>
        In this Chapter, you will learn how to handle strings. AMOS Professional Basic has a
        full range of string manipulation instructions, and experienced Basic programmers should already be
        familiar with the standard syntax used.</P>
</section>

<section id="01-reading-characters-in-a-string">
    <h2>Reading characters in a string</h2>

    <h3 class="command" id="fn-left-dollar">LEFT$</h3>
    <p><i>function: return the leftmost characters of a string</i><BR>
        destination$=<b>Left$</b>(source$,number)<BR>
        <b>Left$</b>(destination$,number)=source$</P>

    <P>
        LEFT$ reads the specified number of characters in a source string, starting from the
        left-hand side, and copies them into a destination string. The first type of usage of this function
        creates a new destination string from the chosen number of characters of the source string. For example:</P>

<code class="prefix edit">Do
 Input "Type in a string:";S$
 Print "Display how many characters from"
 Input "the left?";N
 Print Left$(S$,N)
Loop
</code>

    <P>The second type of usage replaces the leftmost number of characters in the destination
        string with the equivalent number of characters from the source string. For example:</P>

<code class="prefix edit">A$="**** Basic"
Left$(A$,4)="AMOS"
Print A$
</code>

    <P>Exactly the same processes can be performed with characters from the right-hand side of
        a string, by using the equivalent RIGHT$ function.</P>

    <h3 class="command" id="fn-right-dollar">RIGHT$</h3>
    <p><i>function: return the rightmost characters of a string</i><BR>
        destination$=<b>Right$</b>(source$,number)<BR>
        <b>Right$</b>(destination$,number)=source$</P>

    <P>Here are two examples demonstrating each version of usage:</P>

<code class="prefix edit">Print Right$("IGNORED54321",5)
A$=Right$("REJECTED0123456789",10)
Print A$
</code>

<code class="prefix edit">B$="AMOS ************"
Right$(B$,12)="Professsional"
Print B$
</code>

    <!-- section -->
    <h3 class="command" id="fn-mid-dollar">MID$</h3>
    <p><i>function: return a number of characters from the middle of a string</i><br>
        destination$=<b>Mid$</b>(source$,offset,number)<BR>
        <b>Mid$</b>(destination$,offset,number)=source$</P>

    <P>Similarly, the MID$ function returns characters from the middle of a string, with the
        first number specified in brackets setting the offset from the start of the string and the
        second number setting how many characters are to be fetched. If the number of characters to be
        fetched is omitted from your instruction, then the characters will be read right up to the end of
        the string being examined. Here are some examples:</P>

<code class="prefix edit">Print Mid$("AMOS Professional",6)
Print Mid$("AMOS Professional",6,4)
</code>
<br>
<code class="prefix edit">A$="AMOS Professional ***"
Mid$(A$,19)="Basic"
Print A$
Mid$(A$,19,3)="Mag"
Print A$
</code>
</section>

<section id="02-finding-characters-in-a-string">
    <h2>Finding characters in a string</h2>

    <p>It is often necessary to search through a mass of data for a particular reference, in
        other words, to search through strings for individual characters or sub-strings. Similarly, you may
        wish to write an adventure game where lines of text must be broken down into individual commands.</p>

    <h3 class="command" id="fn-instr">INSTR</h3>
    <p><i>function: search for occurrences of one string within another string</i><br>
        x=<b>Instr</b>(host$,guest$)<BR>
        x=<b>Instr</b>(host$,guest$,start of search position)</P>

    <P>
        INSTR allows you to search for all instances of one string inside another. In the
        following examples, the "host" strings are searched for the first occurrence of the "guest" strings
        you are seeking. If the relevant string is found, its location will be reported in the form of the
        number of characters from the left-hand side of the host string. If the search is unsuccessful, a
        result of zero will be given.</P>


<code class="prefix edit">Print Instr("AMOS Professional","AMOS")
Print Instr("AMOS Professional","O")
Print Instr("AMOS Professional","o")
Print Instr("AMOS Professional","Provisional")
</code>
<br>
<code class="prefix edit">Do
 Input "Type in a host string:";H$
 Input "Type in a guest string to be found:";G$
 X=Instr(H$,G$)
 If X=0 Then Print G$;" Not found"
 If X&lt;&gt;0 Then Print G$;" Found at position ";X
Loop
</code>

    <P>
        Normally, the search will begin from the first character at the extreme left-hand side
        of the host string, but you may begin searching from any position by specifying an optional number of
        characters from the beginning of the host string. The optional start-of-search position
        can range from zero to the maximum number of characters in the host string to be searched. For
        example:</P>

<code class="prefix edit">Print Instr("AMOS PROFESSIONAL","O",0)
Print Instr("AMOS PROFESSIONAL","O",4)
</code>
</section>

<section id="03-converting-strings">
    <h2>Converting strings</h2>

    <h3 class="command" id="fn-upper-dollar">UPPER$</h3>
    <p><i>function: convert a string of text to upper case</i><BR>
        new$=<b>Upper$</b>(old$)</P>

    <P>This function converts the characters in a string into upper case (capital) letters,
        and places the result into a new string. For example:</P>

<code class="prefix direct">Print Upper$("aMoS pRoFeSsIoNaL")</code>

    <h3 class="command" id="fn-lower-dollar">LOWER$</h3>
    <p><i>function: convert a string of text to lower case</i><BR>
        new$=<b>Lower$</b>(old$)</P>

    <P>
        This works in the same way as UPPERS, but translates all the characters in a string
        into nothing but lower case (small) letters. These sorts of text conversions are particularly useful
        for interpreting user-input in interactive data programs and adventure games, because input
        can be converted into a standard format which is understood by your programs. For example:</P>

<code class="prefix edit">Input "Do you want to continue? (Yes or No)";ANSWER$
ANSWER$=Lower$(ANSWER$) : If ANSWER$="no" Then Edit
Print "OK. Continuing with your program"
</code>

    <h3 class="command" id="fn-str-dollar">STR$</h3>
    <p><i>function: convert a number into a string</i><BR>
        s$=<b>Str$</b>(number)</P>

    <P>
        Str$ converts a real number variable into a string. This can be used to overcome
        limitations posed by functions like CENTRE, which does not accept numbers as parameters, but will work
        happily with parameters in the form of strings. Here is an example:</P>

<code class="prefix edit">Centre "Remaining memory is"+Str$(Chip Free)+" Bytes"</code>

    <h3 class="command" id="fn-val">VAL</h3>
    <p><i>function: convert a string of digits into a number</i><BR>
        v=<b>Val</b>(x$)<BR>
        v#=<b>Val</b>(x$)</P>

    <p>
        To perform the reverse task to STR$, the VAL function converts a list of decimal digits
        stored in a string, changing them into a number. If this process fails for any reason, a value of
        zero will be returned. For example:</P>

<code class="prefix direct">X=Val("1234") : Print X</code>

    <h3 class="command" id="fn-string-dollar">STRING$</h3>
    <p><i>function: create a new string from an existing string</i><BR>
        new$=<b>String$</b>(existing$, number)</P>

    <P>
        Do not confuse this with STR$, which converts numbers into a string. The STRING$
        function creates a new string filled with the required number of copies of the first character from
        an existing string. For instance, the following example produces a new string containing ten
        copies of the character "A".</P>

<code class="prefix edit">Print String$("AMOS Professional is a joy forever",10)</code>

</section>

<section id="04-manipulating-strings">
    <h2>Manipulating strings</h2>

    <p>Sometimes you may want to handle your strings for special purposes. For example, if you
        wish to pad out a piece of text before it gets printed onto the screen, you will need an
        accurate method of creating spaces in the string.</p>

    <h3 class="command" id="fn-space-dollar">SPACE$</h3>
    <p><i>function: space out a string</i><BR>
        s$=<b>Space$</b>(number of spaces)</P>

    <P>Try the following example:</p>

<code class="prefix edit">Print "Ten";Space$(10);"spaces"</code>

    <h3 class="command" id="fn-flip-dollar">FLIP$</h3>
    <p><i>function: invert a string</i><BR>
        inverted$=<b>Flip$</b>(original$)</P>

    <P>This function simply reverses the order of the characters held in an existing string.
        For example:</P>

<code class="prefix direct">Print Flip$("SOMA gnippilf")</code>

    <h3 class="command" id="fn-repeat-dollar">REPEAT$</h3>
    <p><i>function: repeat a string</i><BR>
        r$=<b>Repeat$</b>(text$,number)</P>

    <P>
        To repeat the same string of characters using a single PRINT statement, follow your
        string of text with the number of times you want the repetition. Allowable values are between 1 and 127.
        Whenever the string is printed, a sequence of control characters is automatically added to
        the r$ variable, in the following format:</P>

    <PRE>
Chr$(27)+"RO"+A$+Chr$(27)+"R"+Chr$(48+n)
</PRE>
</section>

<section id="05-getting-information-about-strings">
    <h2>Getting information about strings</h2>
    The next three functions are provided to discover particular properties of strings.</P>

    <h3 class="command" id="fn-chr-dollar">CHR$</h3>
    <p><i>function: return the character with a given ASCII code</i><BR>
        s$=<b>Chr$</b>(code number)</P>

    <P>
        The CHR$ function creates a string that contains a single character generated by a
        given ASCII code number. Note that only the characters with ASCII code numbers 32 to 255 are printable
        on the screen. Others are used internally as control codes. Match characters with their codes
        using this routine:</P>

<code class="prefix edit">For S=32 To 255: Print Chr$(S); : Next S</code>

    <h3 class="command" id="fn-asc">ASC</h3>
    <p><i>function: Give the ASCII code of a character</i><BR>
        code=<b>Asc</b>(a$)</P>

    <P>To get the internal ASCII code of the first character in a string, use the ASC function
        like this:</P>

<code class="prefix edit">Print Asc("B")
Print Asc("AMOS Professional")
</code>

    <h3 class="command" id="fn-len">LEN</h3>
    <p><i>function: give the length of a string</i><BR>
        length=<b>Len</b>(a$)</P>

    <P>The LEN function returns the number of characters stored in a string. For example:</P>

<code class="prefix direct">Print Len("0123456789")</code>

</section>

<section id="06-array-operations">
    <h2>Array operations</h2>

    <P>To end this Chapter, here are a pair of useful instructions for manipulating arrays.</P>

    <h3 class="command" id="i-sort">SORT</h3>
    <p><i>instruction: sort all elements in an array</i><BR>
        <b>Sort</b> a(0)<BR>
        <b>Sort</b> a#(0)<BR>
        <b>Sort</b> a$(0)</P>

    <P>The SORT instruction arranges the contents of any array into ascending order, and the
        array may contain integers, floating point numbers or strings.</P>

    <p>
        The starting point of your table is specified by the a$(0) parameter, and it must always be set to
        the first item in the array, which is item number zero. For example:</P>

<code class="prefix edit">N=5 : P=0
Dim A(N)
Print "Type in ";N," numbers, or enter 0"
Print "to stop entry and begin sort"
Repeat
  Input A(P)
  If A(P)=0
     Dec P
     Exit
  End If
  If P=N-1 Then Exit
  Inc P
Until False
Sort A(0)
For X=N-P To N
  Print A(X)
Next X
</code>

    <h3 class="command" id="fn-match">MATCH</h3>
    <p><i>function: search an array for a value</i><BR>
        x=<b>Match</b>(array(0),value)<br>
        x=<b>Match</b>(array#(0),value#)<br>
        x=<b>Match</b>(array$(0),value$)</P>

    <P>
        MATCH searches through an array that has already gone through the SORT process, looking
        for a given value. If the value is found then x is loaded with the relevant index number.
        However, if the search is not successful the result will be negative. If you take the absolute value
        of this result, the item which came closest to your original search parameter is provided. Only
        arrays with a single dimension can be checked in this way, and they must already be sorted before
        MATCH can be called.</P>

    <P>For example:</P>

<code class="prefix edit">Read N : Dim D$(N)
For X=0 To N-1 : Read D$(X) : Next X
Sort D$(0)
Do
  REINPUT:
  Input A$
  If A$=" "Then End
  If A$="print all data"
    For X=1 To N: Print D$(X) : Next X: Goto REINPUT
  End If

  POS=Match(D$(0),A$)
  If POS&lt;-N-1
    If POS&gt;-10
      Print "Not found. Nearest to ";D$(1) : Goto JMP
    Else
      Print "Not found. Nearest to ";D$(N) : Goto JMP
    End if
  End If
  If POS&gt;0 Then Print "Found ",DS(POS);" in record ";POS
  If POS&lt;0 Then Inc POS : Print "Not found. Nearest to ":DS(Abs(POS))
  JMP:
Loop
Data 8,"Mercury","Venus","Earth","Mars","Saturn","Jupiter","Neptune","Tharg"
</code>

    <P>
        Test that example out by entering various inputs, including the names of planets,
        single characters in upper and lower case and "print all data". Obviously MATCH can be used with
        the INSTR function to set up a powerful parser routine, for interpreting user input in an
        adventure game.</P>
</section>


<footer>
<a href="05-01-the-bare-bones.html" rel="prev">The Bare Bones</a>
<a href="index.html">Contents</a>
<a href="14-appendix-g-command-index.html">Index</a>
<a href="05-03-maths.html" rel="next">Maths</a>
</footer>

</body>
</html>
